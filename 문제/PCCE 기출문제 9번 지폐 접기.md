# 문제: 지폐 접기

## 문제 설명

민수는 다양한 지폐를 수집하는 취미가 있으며, 지갑에 넣기 위해 지폐를 여러 번 접어야 할 때가 있습니다. 지폐는 항상 길이가 긴 쪽을 먼저 반으로 접으며, 지갑에 넣을 수 있을 때까지 접어야 합니다.

### 규칙
1. 지폐의 긴 쪽을 반으로 접습니다.
2. 접기 전 길이가 **홀수**이면, 소수점 이하는 버립니다. 즉, `floor(길이 / 2)`를 적용합니다.
3. 지폐를 접어서 지갑에 들어갈 수 있는 크기(가로, 세로)보다 작아질 때까지 접습니다.
4. 접힌 상태에서 90도 회전하여 지갑에 넣을 수도 있습니다.

### 입력
- `wallet`: 지갑의 가로, 세로 크기를 담은 정수 리스트 (예: `[30, 15]`)
- `bill`: 지폐의 가로, 세로 크기를 담은 정수 리스트 (예: `[26, 17]`)

### 출력
- 지폐를 접어서 지갑에 넣을 수 있을 때까지의 **최소 접는 횟수**를 반환합니다.

### 예시
#### 입력 1
```python
wallet = [30, 15]
bill = [26, 17]
```
### 출력 1
```python
1
```
### 입력 2
```python
wallet = [50, 50]
bill = [100, 241]
```
### 출력 2
```python
4
```
## 문제 분석

### 핵심 아이디어
- 지갑에 지폐를 넣기 위해서는, 지갑의 크기보다 지폐의 크기를 줄여야 합니다. 이때 지폐를 접는 것은 항상 긴 쪽을 절반으로 나누는 방식으로 이루어지며, 접힌 횟수가 최소가 되도록 해야 합니다.
- 지폐는 가로, 세로로 주어지므로, 각 접힌 상태에서 지갑에 넣을 수 있는지 확인하고, 필요하면 지폐를 90도 돌려서 다시 확인할 수 있습니다.

### 해결 방법
1. **지갑과 지폐의 크기를 비교**하여 지폐가 지갑보다 클 경우 지폐의 긴 쪽을 반으로 접습니다.
2. 접을 때마다 **횟수를 카운팅**하고, 접힌 지폐가 지갑보다 작거나 같아지면 멈춥니다.
3. **두 가지 경우**를 고려해야 합니다:
    - 지폐가 90도 회전하지 않은 상태에서 지갑에 들어가는지 확인
    - 지폐를 90도 회전시켜서 지갑에 들어가는지 확인
4. 두 경우 중 **더 적은 횟수**를 반환합니다.

## 알고리즘 설명

### Step 1: 지폐의 긴 쪽을 확인하고 접기
- 지폐의 두 측정값 중 긴 쪽을 반으로 나눕니다. 나눌 때 소수점이 있을 경우 버리고, 접은 횟수를 카운트합니다. 그 후 지갑에 넣을 수 있는지 확인합니다.

### Step 2: 90도 회전 고려
- 지폐를 반으로 접을 때마다 90도 회전한 상태에서도 지갑에 들어갈 수 있는지를 체크합니다. 두 가지 상황 중 최소의 접기 횟수를 반환합니다.

### Step 3: 반복
- 위 과정을 반복하며, 지폐가 지갑에 들어갈 수 있을 때까지 접습니다.

## 시간 복잡도
- 각 접기 연산은 지폐의 크기가 절반으로 줄어드는 방식이므로, 지폐의 크기가 `m`이라고 할 때, 접는 최대 횟수는 **O(log m)**입니다. 따라서 시간 복잡도는 **O(log(max(bill)))**입니다.

## 공간 복잡도
- 함수에서 사용하는 메모리는 상수 공간이므로, 공간 복잡도는 **O(1)**입니다.
